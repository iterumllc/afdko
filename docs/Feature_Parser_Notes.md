---
title: MakeOTFEXE Feature File Parser Notes
layout: default
---

MakeOTFEXE Feature File Parser Notes
---

Copyright 2021 Adobe. All Rights Reserved. This software is licensed as
OpenSource, under the Apache License, Version 2.0. This license is available at:
http://opensource.org/licenses/Apache-2.0.

Document version 0.2
Last updated 23 May 2021

## 1. Introduction

In 2021 the code in `makeotfexe` that parses and processes feature files was
upgraded from a pccts (Antlr 1) implementation in C to an Antlr 4
implementation in C++.  One reason for the change was to provide a more
contemporary and better documented context for implementation of future changes
to the format of feature files, including additional commands for variable
fonts. This document discusses the new system, sometimes in contrast to the
previous system, to aid those future changes. 

## 2. Files

The pccts-based parser had a single source file with lexigraphic tokens, the
feature file grammar, and snippets of C code (mostly to functions defined in
`feat.c`) to process the files. In the Antlr 4 implementation the lexer is
defined primarily in `FeatLexerBase.g4` and the file grammar in
`FeatParser.g4`. Neither of these include target-language code and therefore
could be used for feature file parsing in other target languages such as Java
or Python.

The additional file `FeatLexer.g4` imports `FeatLexerBase.g4` and has a small
amount of C++ code to recognize `anon` blocks. It is this file that defines
the actual Lexer and the generated files are accordingly `FeatLexer.h` and
`FeatLexer.cpp`.

The parser is similarly implemented by `FeatParser.h` and `FeatParser.cpp` and
there is also an abstract `FeatParserVisitor` class and a
`FeatParserBaseVisitor` implementation generated by Antlr 4. `FeatParser.h` is
the most useful file to refer to; it has the naming conventions and internal
structure of each of the nodes of the parse tree.

All of the derived files can currently be regenerated by running `make` in
the `hotconv` source directory, assuming `antlr4` itself (it is a Java
application) is installed on the machine and in your path. However, as with 
the previous system the derived files are checked into git so that the system
can be built without having `antlr4` installed.

The new files `FeatCtx.h` and `FeatCtx.cpp` correspond to the old `feat.c`.
This C++ class mostly consists of utility and adapter code that should be
recognizable to people familiar with the previous system. The new files 
`FeatVisitor.h` and `FeatVisitor.cpp` correspond to the snippets of C in
the old `featgram.g`, but in contrast with `FeatCtx` the new code is quite
different.

## 4. `FeatVisitor` and the Visitor Semantic

Antlr 4 can be used in different ways but its authors recommend using the
parser to build a parse tree and then traversing that tree with code written in
the target language. Antlr can optionally produce "listeners" and "visitors"
and the `makeotfexe` code uses the latter. In effect there is one virtual
method corresponding to each of the types of node in the tree. The default
implementation for a node just calls the method for each child node passing it
the child context.

One processes the tree by replacing the default implementation for a given node
with one to do the processing. Here, for example, is a simplified version of
the present visitor method for feature block nodes:

```
antlrcpp::Any FeatVisitor::visitFeatureBlock(FeatParser::FeatureBlockContext *ctx) {
    if ( stage == vExtract ) {
        Tag t = checkTag(ctx->starttag, ctx->endtag);
        TOK(ctx);
        fc->startFeature(t);
    }

    for (const auto &i : ctx->statement())
        visitStatement(i);

    if ( stage == vExtract ) {
        TOK(ctx->endtag);
        fc->endFeature();
    }
    return nullptr;
}
```

`checktag` is a utility method that verifies the start and end tags are equal
(or outputs an error) and returns the tag. `startFeature()` is a `FeatCtx`
method that prepares for new feature statements and `endFeature()` is a 
corresponding method that wraps up feature processing. In between the method
calls `visitStatement()` on each child `statement` node in order, fulfilling
its role as a "visitor".

The `stage` guards represent two stages of tree processing: `vInclude` and
`vExtract`. `vInclude` only involves opening and parsing included feature
files, and therefore the `vInclude` processing stage needs to reach each
include node without doing anything else. The parse tree is processed in
`vExtract`.

The remaining unreferenced method (besides the `antlrcpp::Any` return value,
which is an unused Antlr-ism) is the `TOK()` method. This is actually a method
and two methods templates in `FeatVisitor.h` that accept and return tree 
nodes or tokens. `TOK` should be called on a relevant child node, and sometimes
the current node (as in `TOK(ctx)`) before calling out to a `FeatCtx()` method 
to set the token used to report the line number and character offset of a 
warning or error. 

## 5. Document revisions

**v0.2 [23 May 2021]: Update when feature complete**

**v0.1 [11 May 2021]: First version**
