---
title: MakeOTFEXE Feature File Parser Notes
layout: default
---

MakeOTFEXE Feature File Parser Notes
---

Copyright 2021 Adobe. All Rights Reserved. This software is licensed as
OpenSource, under the Apache License, Version 2.0. This license is available at:
http://opensource.org/licenses/Apache-2.0.

Document version 0.1
Last updated 11 May 2021

## 1. Introduction

In 2021 the code in `makeotfexe` that parses and processes feature files was
upgraded from a pccts (Antlr 1) implementation in C to an Antlr 4
implementation in C++.  One reason for the change was to provide a more
contemporary and better documented context for implementation of future changes
to the format of feature files, including additional commands for variable
fonts. This document discusses the new system, sometimes in contrast to the
previous system, to aid those future changes. 

The present version of this document is a rough, tentative draft intended to
help get through the later stages of reimplementation.

## 2. Status

At present time the Linux/GCC makefiles have been modified to build the new
parser while the Mac and Windows files have *not* been modified and *will not
work*. This should change shortly (probably via a switch to CMake-driven
builds). At present the Antlr 4 Cpp runtime must also be installed in order
to build `makeotfexe`. This will eventually be added to the git repository
and built as a static library.

The implemented grammar is still quite minimal, it basically amounts to
`languagesystem` statements, includes (at the top level and in feature blocks),
`feature` blocks with *most* substitutions, and `anon` blocks. So, for example,
`GSUB_2.fea` and `GSUB_3.fea` in `tests/makeotfexe_data/input/fealib` should
work. `aalt` processing is also largely complete.

The error/warning message system is similar but has been overhauled. The
changes should be considered a draft of one potential direction. One
significant change is that all messages reported during feature processing now
include line number and character offsets. (In the previous implementation only
the line number was provided and only for some messages.) Feedback on error
message structure will be appreciated.

## 3. Files

The pccts-based parser had a single source file with lexigraphic tokens, the
feature file grammar, and snippets of C code (mostly to functions defined in
`feat.c`) to process the files. In the Antlr 4 implementation the lexer is
defined primarily in `FeatLexerBase.g4` and the file grammar in
`FeatParser.g4`. Neither of these include target-language code and therefore
could be used for feature file parsing in other target languages, such as Java
or Python.

The additional file `FeatLexer.g4` imports `FeatLexerBase.g4` and has some C++
code to recognize `anon` blocks. It is this file that defines the actual Lexer
and the generated files are accordingly `FeatLexer.h` and `FeatLexer.cpp`.

The parser is similarly defined in `FeatParser.h` and `FeatParser.cpp` and
there is also an abstract `FeatParserVisitor` class and a
`FeatParserBaseVisitor` implementation generated by Antlr 4. The most useful
file to actually read is `FeatParser.h`, which has the naming conventions
and internal structure of each of the nodes of the parse tree.

All of these derived files can currently be regenerated by running `make` in
the `hotconv` source directory, assuming `antlr4` itself (it is a Java
application) is installed on the machine and in your path. However, as with 
the previous system the derived files are checked into git so that the system
can be built without having `antlr4` installed. (As noted above, you still 
need the Cpp runtime.) 

The new files `FeatCtx.h` and `FeatCtx.cpp` correspond to the old `feat.c`.
This C++ class mostly consists of utility and adapter code that should be
recognizable to people familiar with the previous system. The new files 
`FeatVisitor.h` and `FeatVisitor.cpp` correspond to the snippets of C in
the old `featgram.g`, but in contrast with `FeatCtx` the new code is quite
different.

## 4. `FeatVisitor` and the Visitor Semantic

Antlr 4 can be used in different ways but its authors recommend using the
parser to build a parse tree and then traversing that tree with code written in
the target language. Antlr can optionally produce "listeners" and "visitors" and
the `makeotfexe` code uses the latter. In effect there is one virtual method
corresponding to each of the types of node in the tree. The default
implementation for a node just calls the method for each child node passing
it the child context.

One processes the tree by replacing the default implementation for a given node
with one to do the processing. Here, for example, is a simplified version of
the present visitor method for feature block nodes:

```
antlrcpp::Any FeatVisitor::visitFeatureBlock(FeatParser::FeatureBlockContext *ctx) {
    if ( stage == vExtract ) {
        Tag t = checkTag(ctx->starttag, ctx->endtag);
        TOK(ctx);
        fc->startFeature(t);
    }

    for (const auto &i : ctx->statement())
        visitStatement(i);

    if ( stage == vExtract ) {
        TOK(ctx->endtag);
        fc->endFeature();
    }
    return nullptr;
}
```

`checktag` is a utility method that verifies the start and end tags are equal
(or outputs an error) and returns the tag. `startFeature()` is a `FeatCtx`
method that prepares for new feature statements and `endFeature()` is a 
corresponding method that wraps up feature processing. In between the method
calls `visitStatement()` on each child `statement` node in order, fulfilling
its role as a "visitor".

The `stage` guards represent two stages of tree processing: `vInclude` and
`vExtract`. `vInclude` only involves opening and parsing included feature
files, and therefore the `vInclude` processing stage needs to reach each
include node without doing anything else. The parse tree is processed in
`vExtract`.

The remaining unreferenced method (besides the `antlrcpp::Any` return value,
which is an unused Antlr-ism) is the `TOK()` method. This is actually a method
and two methods templates in `FeatVisitor.h` that accept and return tree 
nodes or tokens. `TOK` should be called on a relevant child node, and sometimes
the current node (as in `TOK(ctx)`) before calling out to a `FeatCtx()` method 
to set the token used to report the line number and character offset of a 
warning or error. 

## 5. Document revisions

**v0.1 [11 May 2021]: First version**
